## Что такое словари в ClickHouse?

Словари в ClickHouse — это структуры данных, которые хранят пары ключ-значение и используются для быстрого доступа к данным без необходимости выполнения сложных JOIN-ов или подзапросов. Словари обычно загружаются в оперативную память, что обеспечивает высокую производительность.

- **Основное назначение**:
    - Подстановка значений (например, перевод ID в название).
    - Замена JOIN-ов для оптимизации производительности.
    - Кэширование данных из внешних источников.
- **Применение**:
    - Обогащение данных (например, добавление информации о пользователе по его ID).
    - Фильтрация или группировка с использованием внешних данных.
    - Работа с редко изменяемыми справочниками.

---

## Типы словарей

ClickHouse поддерживает несколько типов словарей, которые определяют, как данные хранятся и обрабатываются:

1. **Простые словари (Flat, Hashed, Cache)**:
    - **Flat**: Хранит все данные в оперативной памяти в виде плоского массива. Подходит для небольших словарей (до миллионов записей).
    - **Hashed**: Использует хэш-таблицу. Подходит для больших словарей, обеспечивает быстрый доступ по ключу.
    - **Cache**: Кэширует данные из внешнего источника, периодически обновляя их. Полезен для часто запрашиваемых данных.
2. **Сложные словари (ComplexKeyHashed, ComplexKeyCache)**:
    - Поддерживают составные ключи (например, кортежи или массивы).
    - Используются, когда ключ состоит из нескольких полей.
3. **Диапазонные словари (RangeHashed)**:
    - Поддерживают диапазоны для ключей (например, временные интервалы).
    - Полезны для работы с данными, где ключ — это диапазон значений.

---

## Источники данных для словарей

Словари могут загружать данные из различных источников:

- **ClickHouse-таблицы**:
    - Данные берутся из локальной таблицы ClickHouse.
    - Пример: Справочник с ID и названиями регионов.
- **Файлы**:
    - Поддерживаются форматы CSV, TSV, JSON и другие.
    - Файлы должны быть доступны на сервере ClickHouse.
- **HTTP/HTTPS**:
    - Данные загружаются через HTTP-запросы (например, из API).
    - Полезно для интеграции с внешними системами.
- **Базы данных**:
    - Поддерживаются MySQL, PostgreSQL, SQLite и другие через ODBC или прямое подключение.
- **Kafka**:
    - Данные загружаются из топиков Kafka для потоковой обработки.

---

## Создание словаря

Словари создаются с помощью DDL-запроса `CREATE DICTIONARY`. Пример создания словаря на основе ClickHouse-таблицы:

```sql
CREATE DICTIONARY regions_dict
(
    region_id UInt32,
    region_name String
)
PRIMARY KEY region_id
SOURCE(CLICKHOUSE(
    TABLE 'regions'
    DB 'default'
    QUERY 'SELECT region_id, region_name FROM regions'
))
LAYOUT(HASHED())
LIFETIME(MIN 60 MAX 3600);
```

- **Разбор**:
    - `CREATE DICTIONARY`: Создает словарь с именем `regions_dict`.
    - `region_id`, `region_name`: Поля словаря (ключ и значение).
    - `PRIMARY KEY`: Указывает ключ для поиска.
    - `SOURCE`: Источник данных (таблица `regions` в базе `default`).
    - `LAYOUT`: Тип словаря (`HASHED` для хэш-таблицы).
    - `LIFETIME`: Время жизни данных в секундах (обновление каждые 60–3600 секунд).

---

## Использование словарей в запросах

Словари интегрируются в SQL-запросы через функции `dictGet*` и `dictHas`.

### Основные функции:

1. **dictGet**:
    
    - Возвращает значение из словаря по ключу.
    - Пример:
        
        ```sql
        SELECT
            user_id,
            dictGet('regions_dict', 'region_name', region_id) AS region_name
        FROM users;
        ```
        
        Здесь для каждого `region_id` из таблицы `users` подставляется `region_name` из словаря.
2. **dictGetOrDefault**:
    
    - Возвращает значение или значение по умолчанию, если ключ не найден.
    - Пример:
        
        ```sql
        SELECT
            user_id,
            dictGetOrDefault('regions_dict', 'region_name', region_id, 'Unknown') AS region_name
        FROM users;
        ```
        
3. **dictHas**:
    
    - Проверяет, существует ли ключ в словаре.
    - Пример:
        
        ```sql
        SELECT
            user_id,
            dictHas('regions_dict', region_id) AS has_region
        FROM users;
        ```
        
4. **dictGet с составными ключами**:
    
    - Для словарей с `ComplexKeyHashed` можно использовать кортежи.
    - Пример:
        
        ```sql
        SELECT dictGet('complex_dict', 'value', tuple(region_id, user_type)) FROM users;
        ```
        

---

## Пример: Словарь с внешним HTTP-источником

Создание словаря, который загружает данные через HTTP:

```sql
CREATE DICTIONARY currency_dict
(
    currency_code String,
    rate Float32
)
PRIMARY KEY currency_code
SOURCE(HTTP(
    URL 'https://api.example.com/currencies'
    FORMAT 'JSONEachRow'
))
LAYOUT(HASHED())
LIFETIME(3600);
```

- **Использование**:
    
    ```sql
    SELECT
        product_id,
        price * dictGet('currency_dict', 'rate', currency_code) AS price_usd
    FROM products;
    ```
    

---

## Оптимизация и рекомендации

1. **Выбор LAYOUT**:
    - Используйте `Flat` для словарей до 10,000 записей.
    - Используйте `Hashed` для больших словарей (миллионы записей).
    - Используйте `Cache` для внешних источников с частыми запросами.
2. **Контроль LIFETIME**:
    - Устанавливайте разумные значения `MIN` и `MAX` для обновления данных.
    - Для статичных данных используйте `LIFETIME(0)` (без обновления).
3. **Мониторинг памяти**:
    - Словари хранятся в RAM. Проверяйте использование памяти через системные таблицы (`system.dictionaries`).
        
        ```sql
        SELECT
            name,
            bytes_allocated,
            last_successful_update_time
        FROM system.dictionaries;
        ```
        
4. **Обработка ошибок**:
    - Используйте `dictGetOrDefault` или `dictGetOrNull` для обработки отсутствующих ключей.
5. **Тестирование**:
    - Проверяйте словарь перед использованием:
        
        ```sql
        SELECT dictGet('regions_dict', 'region_name', 1);
        ```
        

---

## Ограничения

- **Память**: Словари потребляют оперативную память. Большие словари могут привести к нехватке RAM.
- **Обновление**: Данные в словаре не всегда обновляются мгновенно (зависит от `LIFETIME`).
- **Сложные ключи**: Работа с составными ключами может быть менее интуитивной.
- **Внешние источники**: Зависимость от внешних API или баз данных может привести к задержкам или ошибкам.

---

## Полезные ссылки

- [Официальная документация ClickHouse: Dictionaries](https://clickhouse.com/docs/en/sql-reference/dictionaries/)
- [System.dictionaries](https://clickhouse.com/docs/en/operations/system-tables/dictionaries/)
- [Функции для работы со словарями](https://clickhouse.com/docs/en/sql-reference/functions/ext-dict-functions/)