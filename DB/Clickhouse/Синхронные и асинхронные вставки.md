
## Синхронные вставки

### Определение

- **Синхронная вставка** (`INSERT`) — запрос, который завершается только после полной записи данных на диск и их доступности для чтения в запросах `SELECT`.
- Клиент ждет подтверждения успешной записи.

### Как работает

1. Принимает данные от клиента.
2. Формирует новую часть данных (part).
3. Записывает часть на диск (`columns.bin`, `primary.idx` и др.).
4. Обновляет метаданные таблицы.
5. Подтверждает клиенту успех операции.

- При репликации данные синхронизируются с другими узлами перед ответом.

### Пример

```sql
INSERT INTO events (event_time, category, event_data) VALUES
('2025-01-01 10:00:00', 'clicks', 'user_123'),
('2025-01-01 10:01:00', 'views', 'user_456');
```

- Данные сразу доступны для `SELECT`:

```sql
SELECT * FROM events WHERE event_time = '2025-01-01 10:00:00';
```

### Особенности

- **Гарантия завершения**: Данные записаны и доступны.
- **Задержка**: Зависит от объема данных и скорости диска.
- **Надежность**: Высокая, клиент знает об успехе.
- **Ресурсоемкость**: Нагружает сервер при частых или больших вставках.

### Когда использовать

- Нужна немедленная доступность данных.
- Небольшие или редкие вставки.
- Требуется строгая консистентность (например, финансы).

---

## Асинхронные вставки

### Определение

- **Асинхронная вставка** — запрос, который возвращает управление клиенту сразу после приема данных, до их записи на диск.
- Запись выполняется в фоновом режиме.

### Как работает

1. Данные помещаются в буфер (в памяти или на диске).
2. Клиенту возвращается подтверждение приема.
3. В фоне данные записываются в часть и добавляются в таблицу.
4. Данные становятся доступны для `SELECT` с небольшой задержкой.

### Как включить

- Через `clickhouse-client`:

```bash
clickhouse-client --async_insert=1
```

- Через HTTP:

```bash
curl -X POST 'http://localhost:8123/?async_insert=1' -d 'INSERT INTO events VALUES'
```

- В конфигурации сервера:

```xml
<clickhouse>
    <async_insert>1</async_insert>
</clickhouse>
```

### Пример

```sql
INSERT INTO events (event_time, category, event_data) VALUES
('2025-01-01 10:02:00', 'clicks', 'user_789');
```

- С параметром `--async_insert=1` клиент получает немедленный отклик.
- Данные могут быть недоступны для `SELECT` до завершения фоновой записи:

```sql
SELECT * FROM events WHERE event_time = '2025-01-01 10:02:00';
```

### Особенности

- **Быстрый отклик**: Минимальная задержка для клиента.
- **Фоновая обработка**: Данные появляются с задержкой.
- **Меньшая нагрузка на клиент**: Не ждет записи.
- **Риск потери данных**: Возможен при сбое сервера до записи (минимизируется временными файлами).
- **Консистентность**: Временная недоступность данных.

### Когда использовать

- Высоконагруженные системы с частыми вставками (логи, метрики).
- Задержка ответа критична, а задержка видимости данных допустима.
- Реал-тайм аналитика с отложенными запросами.

---

## Зачем нужны асинхронные вставки и какие проблемы они решают

### 1. Снижение задержки для клиента

- **Проблема**: Синхронные вставки заставляют клиента ждать, что снижает пропускную способность в высоконагруженных системах.
- **Решение**: Асинхронные вставки возвращают отклик сразу, позволяя клиенту продолжать работу.
- **Пример**:
    
    - Мониторинг отправляет метрики каждую секунду:
    
    ```sql
    INSERT INTO metrics (timestamp, value) VALUES ('2025-01-01 10:00:00', 42);
    ```
    
    - Асинхронная вставка сокращает время ответа с 10 мс до <1 мс.

### 2. Увеличение пропускной способности

- **Проблема**: Синхронные вставки ограничивают количество запросов, которые сервер может обработать.
- **Решение**: Буферизация данных и фоновая запись распределяют нагрузку.
- **Пример**:
    
    - Веб-приложение отправляет тысячи событий:
    
    ```bash
    curl -X POST 'http://localhost:8123/?async_insert=1' -d 'INSERT INTO events VALUES (...1000 events...)'
    ```
    

### 3. Обработка пиковых нагрузок

- **Проблема**: Всплески данных (например, во время акций) перегружают сервер.
- **Решение**: Асинхронные вставки сглаживают пики, накапливая данные в буфере.
- **Пример**:
    - Во время Black Friday миллионы событий обрабатываются без блокировки клиентов.

### 4. Упрощение интеграции со стриминговыми системами

- **Проблема**: Стриминговые системы (Kafka, RabbitMQ) требуют высокой скорости отправки.
- **Решение**: Асинхронные вставки минимизируют задержки.
- **Пример**:
    
    - Поток из Kafka:
    
    ```sql
    INSERT INTO events FORMAT JSONEachRow {...event...}
    ```
    

### 5. Снижение нагрузки на клиент

- **Проблема**: Синхронные вставки усложняют логику клиента из-за таймаутов.
- **Решение**: Асинхронные вставки упрощают отправку данных.
- **Пример**:
    
    - Мобильное приложение отправляет события:
    
    ```bash
    curl -X POST 'http://localhost:8123/?async_insert=1' -d 'INSERT INTO user_events VALUES (...event...)'
    ```
    

---

## Потенциальные недостатки асинхронных вставок

1. **Задержка видимости данных**:
    
    - Данные доступны с задержкой (миллисекунды–секунды).
    - **Решение**: Используйте синхронные вставки или настройте `async_insert_max_data_size`.
2. **Риск потери данных**:
    
    - Возможна потеря при сбое сервера до записи.
    - **Решение**: Используйте репликацию и настройте `async_insert_busy_timeout_ms`.
3. **Сложность отладки**:
    
    - Трудно понять, застряли ли данные в буфере.
    - **Решение**: Мониторьте `system.async_inserts`:

```sql
SELECT * FROM system.async_inserts WHERE database = 'default' AND table = 'events';
```

---

## Настройки асинхронных вставок

- **`async_insert`**: Включает асинхронные вставки (`0` — выключено, `1` — включено).
- **`async_insert_max_data_size`**: Максимальный размер буфера (например, `1000000` — 1 МБ).
- **`async_insert_busy_timeout_ms`**: Время ожидания в буфере (например, `200` мс).
- **`async_insert_threads`**: Количество потоков для обработки (например, `16`).

Пример:

```bash
clickhouse-client --async_insert=1 --async_insert_max_data_size=1000000
```

---

## Чередование синхронных и асинхронных вставок

### Проблема

- Чередование требует явного указания `--async_insert=1` или `--async_insert=0`:
    
    - Асинхронная:
    
    ```bash
    clickhouse-client --async_insert=1 --async_insert_max_data_size=1000000 -q "INSERT INTO events VALUES ('2025-01-01 10:00:00', 'clicks', 'user_123')"
    ```
    
    - Синхронная:
    
    ```bash
    clickhouse-client -q "INSERT INTO events VALUES ('2025-01-01 10:01:00', 'views', 'user_456')"
    ```
    
- Ручное изменение параметров неудобно при частом чередовании.

### Решения

#### 1. HTTP-интерфейс

- Управляйте режимом через URL-параметры.
- Пример:
    
    - Асинхронная:
    
    ```bash
    curl -X POST 'http://localhost:8123/?async_insert=1&async_insert_max_data_size=1000000' -d "INSERT INTO events VALUES ('2025-01-01 10:00:00', 'clicks', 'user_123')"
    ```
    
    - Синхронная:
    
    ```bash
    curl -X POST 'http://localhost:8123/' -d "INSERT INTO events VALUES ('2025-01-01 10:01:00', 'views', 'user_456')"
    ```
    

#### 2. Разные сессии в `clickhouse-client`

- Используйте скрипты для разных режимов:
    
    - `async_insert.sh`:
    
    ```bash
    clickhouse-client --async_insert=1 --async_insert_max_data_size=1000000 -q "INSERT INTO events VALUES ('2025-01-01 10:00:00', 'clicks', 'user_123')"
    ```
    
    - `sync_insert.sh`:
    
    ```bash
    clickhouse-client -q "INSERT INTO events VALUES ('2025-01-01 10:01:00', 'views', 'user_456')"
    ```
    

#### 3. Профили настроек

- Настройте профили в `~/.clickhouse-client/config.xml`:

```xml
<config>
    <profiles>
        <default>
            <async_insert>0</async_insert>
        </default>
        <async>
            <async_insert>1</async_insert>
            <async_insert_max_data_size>1000000</async_insert_max_data_size>
        </async>
    </profiles>
</config>
```

- Использование:
    
    - Синхронная:
    
    ```bash
    clickhouse-client --profile=default -q "INSERT INTO events VALUES ('2025-01-01 10:01:00', 'views', 'user_456')"
    ```
    
    - Асинхронная:
    
    ```bash
    clickhouse-client --profile=async -q "INSERT INTO events VALUES ('2025-01-01 10:00:00', 'clicks', 'user_123')"
    ```
    

#### 4. Программная логика (Python)

- Управляйте режимом в коде:

```python
from clickhouse_driver import Client

client = Client(host='localhost')

# Синхронная
client.execute(
    "INSERT INTO events (event_time, category, event_data) VALUES",
    [('2025-01-01 10:01:00', 'views', 'user_456')]
)

# Асинхронная
client.execute(
    "INSERT INTO events (event_time, category, event_data) VALUES",
    [('2025-01-01 10:00:00', 'clicks', 'user_123')],
    settings={'async_insert': 1, 'async_insert_max_data_size': 1000000}
)
```

#### 5. Разные таблицы

- Используйте `events_sync` для синхронных и `events_async` для асинхронных вставок.
- Пример:
    
    - Синхронная:
    
    ```bash
    clickhouse-client -q "INSERT INTO events_sync VALUES ('2025-01-01 10:01:00', 'views', 'user_456')"
    ```
    
    - Асинхронная:
    
    ```bash
    clickhouse-client --async_insert=1 -q "INSERT INTO events_async VALUES ('2025-01-01 10:00:00', 'clicks', 'user_123')"
    ```
    

#### 6. Внешние очереди (Kafka)

- Асинхронные вставки через Kafka:

```sql
CREATE TABLE events_kafka
(
    event_time DateTime,
    category String,
    event_data String
)
ENGINE = Kafka
SETTINGS kafka_broker_list = 'localhost:9092',
         kafka_topic_list = 'events',
         kafka_group_name = 'clickhouse',
         kafka_format = 'JSONEachRow';

CREATE MATERIALIZED VIEW events_mv
TO events
AS SELECT * FROM events_kafka;
```

- Синхронные вставки напрямую:

```bash
clickhouse-client -q "INSERT INTO events VALUES ('2025-01-01 10:01:00', 'views', 'user_456')"
```

---

## Рекомендации

- **Редкие вставки**: Используйте HTTP или `clickhouse-client` с явными параметрами.
- **Частое чередование**: Настройте профили или используйте программную логику (Python).
- **Разные типы данных**: Разделите на таблицы или используйте Kafka.
- **Высокая нагрузка**: Интегрируйте с Kafka для асинхронности.