Ниже приведены примеры кода для организации партиционирования в ClickHouse на основе таблицы событий с полями `event_time` (дата/время) и `category` (категория). Я покажу, как создать таблицу с разными вариантами партиционирования, а также примеры операций с партициями. Все примеры используют движок `MergeTree`, так как он наиболее распространен для таких задач.

---

### 1. Создание таблицы с партиционированием по месяцам

Партиционирование по месяцам на основе столбца `event_time` с использованием функции `toYYYYMM`.

```sql
CREATE TABLE events
(
    event_time DateTime,
    category String,
    event_data String
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(event_time)
ORDER BY (event_time, category)
SETTINGS index_granularity = 8192;
```

**Объяснение**:
- `PARTITION BY toYYYYMM(event_time)`: Данные разбиваются на партиции по году и месяцу (например, `202501`, `202502`).
- `ORDER BY (event_time, category)`: Первичный индекс сортирует данные по `event_time` и `category` для эффективной фильтрации.
- `index_granularity = 8192`: Настройка размера гранулы индекса (по умолчанию 8192, можно настроить под ваши данные).

---

### 2. Создание таблицы с партиционированием по дням

Партиционирование по дням, если запросы часто работают с дневными диапазонами.

```sql
CREATE TABLE events_daily
(
    event_time DateTime,
    category String,
    event_data String
)
ENGINE = MergeTree()
PARTITION BY toYYYYMMDD(event_time)
ORDER BY (event_time, category)
SETTINGS index_granularity = 8192;
```

**Объяснение**:
- `PARTITION BY toYYYYMMDD(event_time)`: Данные делятся на партиции по дням (например, `20250101`, `20250102`).
- Подходит для случаев, когда запросы фильтруют данные по конкретным дням, но увеличивает количество партиций, что может быть накладно при больших объемах данных.

---

### 3. Создание таблицы с партиционированием по категории

Партиционирование по столбцу `category`, если запросы часто фильтруют по категориям.

```sql
CREATE TABLE events_by_category
(
    event_time DateTime,
    category String,
    event_data String
)
ENGINE = MergeTree()
PARTITION BY category
ORDER BY (event_time, category)
SETTINGS index_granularity = 8192;
```

**Объяснение**:
- `PARTITION BY category`: Каждая уникальная категория становится отдельной партицией.
- Полезно, если категории имеют низкую кардинальность (например, 10–100 уникальных значений) и запросы часто фильтруют по `category`.
- Не рекомендуется при высокой кардинальности `category` (например, миллионы уникальных значений), так как это создаст слишком много партиций.

---

### 4. Создание таблицы с комбинированным партиционированием

Партиционирование по комбинации `category` и месяца, если важны оба критерия.

```sql
CREATE TABLE events_combined
(
    event_time DateTime,
    category String,
    event_data String
)
ENGINE = MergeTree()
PARTITION BY (category, toYYYYMM(event_time))
ORDER BY (event_time, category)
SETTINGS index_granularity = 8192;
```

**Объяснение**:
- `PARTITION BY (category, toYYYYMM(event_time))`: Партиции создаются для каждой комбинации категории и месяца (например, `('clicks', 202501)`, `('views', 202501)`).
- Подходит для сценариев, где запросы фильтруют по категории и времени одновременно.
- Увеличивает количество партиций, поэтому используйте с осторожностью.

---

### 5. Операции с партициями

После создания таблицы с партициями можно выполнять различные операции. Вот примеры:

#### Вставка данных
```sql
INSERT INTO events (event_time, category, event_data) VALUES
('2025-01-01 10:00:00', 'clicks', 'user_123'),
('2025-01-15 12:00:00', 'views', 'user_456'),
('2025-02-01 14:00:00', 'clicks', 'user_789');
```

#### Просмотр партиций
Увидеть, какие партиции существуют в таблице:
```sql
SELECT partition, count() AS rows
FROM system.parts
WHERE table = 'events' AND active = 1
GROUP BY partition;
```

#### Удаление партиции
Удалить данные за январь 2025 года:
```sql
ALTER TABLE events DROP PARTITION '202501';
```

#### Оптимизация партиции
Объединить части партиции для повышения производительности (например, после множества вставок):
```sql
OPTIMIZE TABLE events PARTITION '202501' FINAL;
```

#### Заморозка партиции (для бэкапа)
Создать резервную копию данных за январь 2025 года:
```sql
ALTER TABLE events FREEZE PARTITION '202501';
```

#### Копирование партиции в другую таблицу
Скопировать данные из одной партиции в другую таблицу:
```sql
ALTER TABLE events MOVE PARTITION '202501' TO TABLE events_backup;
```

---

### 6. Пример запроса с учетом партиционирования

Допустим, у нас таблица `events` с партиционированием по месяцам. Запрос, который выбирает данные за январь 2025 года:

```sql
SELECT category, count() AS event_count
FROM events
WHERE event_time >= '2025-01-01' AND event_time < '2025-02-01'
GROUP BY category;
```

**Как работает**:
- ClickHouse автоматически выберет только партицию `202501`, игнорируя остальные.
- Первичный индекс по `(event_time, category)` дополнительно ускорит фильтрацию внутри партиции.

---

### Рекомендации по выбору партиционирования

1. **По месяцам (`toYYYYMM`)**:
   - Используйте, если запросы часто фильтруют по месяцам или вы удаляете старые данные (например, храните данные за последние 12 месяцев).
   - Подходит для большинства аналитических таблиц с временными данными.

2. **По дням (`toYYYYMMDD`)**:
   - Используйте, если запросы работают с дневными диапазонами, но будьте осторожны с количеством партиций (365 партиций в год).

3. **По категории**:
   - Подходит для таблиц с низкой кардинальностью категорий и запросами, фильтрующими по `category`.
   - Избегайте при высокой кардинальности, чтобы не создавать слишком много партиций.

4. **Комбинированное партиционирование**:
   - Используйте, если запросы фильтруют по нескольким критериям, но следите за количеством партиций.

5. **Размер партиций**:
   - Стремитесь к партициям размером от нескольких мегабайт до нескольких гигабайт. Слишком маленькие партиции увеличивают накладные расходы, а слишком большие снижают преимущества партиционирования.

---

### Итог

Приведенные примеры показывают, как настроить партиционирование для разных сценариев и управлять партициями. Для вашей таблицы событий с `event_time` и `category` я рекомендую начать с партиционирования по месяцам (`PARTITION BY toYYYYMM(event_time)`), так как это сбалансированный подход для большинства аналитических задач. Если запросы или операции с данными имеют специфические особенности, напишите, и я помогу адаптировать схему!