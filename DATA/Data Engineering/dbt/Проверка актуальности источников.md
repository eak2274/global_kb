## Source Freshness (Актуальность Источников)

Это основной и самый мощный механизм dbt для мониторинга актуальности. Он позволяет вам определить, насколько "свежими" должны быть данные в ваших источниках.

**Как это работает:**

1. **Определение в `schema.yml`:** Вы указываете в конфигурации источника (в файле `models/schema.yml` или `_sources.yml`) столбец с временной меткой (timestamp) и пороговые значения актуальности.
    
    YAML
    
    ```yaml
    # models/schema.yml
    version: 2
    
    sources:
      - name: raw_data # Имя вашего источника (как в dbt_project.yml)
        database: your_raw_db
        schema: public
        tables:
          - name: events # Имя таблицы-источника
            loaded_at_field: event_timestamp # Столбец, по которому отслеживается время последней загрузки/изменения
            freshness:
              warn_after:
                count: 12
                period: hour # Предупреждать, если последние данные старше 12 часов
              error_after:
                count: 24
                period: hour # Ошибка, если последние данные старше 24 часов
            columns:
              - name: event_id
                # ... другие столбцы ...
    ```
    
    - **`loaded_at_field`**: Это самый важный параметр. Указывает на столбец в вашей исходной таблице, который содержит временную метку последней записи, последнего обновления или последнего изменения данных. dbt будет использовать этот столбец для определения "свежести".
        
    - **`warn_after`**: Если разница между текущим временем и самой новой записью в `loaded_at_field` превышает этот порог, dbt выдаст **предупреждение** при выполнении команды `dbt source freshness`.
        
    - **`error_after`**: Если разница превышает этот порог, dbt выдаст **ошибку**, что может остановить конвейер CI/CD, если он настроен на это.
        
2. **Запуск команды `dbt source freshness`:** Эта команда запускает проверку актуальности. Она:
    
    - Запрашивает `MAX(loaded_at_field)` из каждой сконфигурированной таблицы-источника.
        
    - Сравнивает полученную временную метку с текущим временем.
        
    - Выдает предупреждения или ошибки в зависимости от порогов `warn_after` и `error_after`.
        
    
    **Пример вывода:**
    
    ```
    1 of 2 sources fresh: dbt_docs_test.customer_data [OK in 0.0s]
    1 of 2 sources stale: dbt_docs_test.product_catalog [WARN in 0.0s] - last loaded at 2023-10-26 10:00:00 (1 day, 2 hours ago)
    ```
    

Чтобы остановить выполнение пайплайна dbt, если актуальность источников хуже требуемой, вам нужно использовать команду `dbt source freshness` в вашем CI/CD пайплайне и настроить ее так, чтобы она возвращала ошибку, если условия актуальности не соблюдены.

Вот как это обычно делается:

### 1. Настройте `error_after` в `schema.yml`

Это самый важный шаг. Вы должны четко определить, какой порог неактуальности считается критическим и должен вызывать ошибку.

YAML

```
# models/schema.yml
version: 2

sources:
  - name: raw_data
    database: your_raw_db
    schema: public
    tables:
      - name: events
        loaded_at_field: event_timestamp
        freshness:
          warn_after:
            count: 12
            period: hour
          error_after:
            count: 24 # Если данные старше 24 часов, dbt source freshness вернет ошибку
            period: hour
```

### 2. Запустите `dbt source freshness` в вашем CI/CD пайплайне

В вашем CI/CD скрипте (например, GitHub Actions, GitLab CI/CD, Jenkins, Airflow, Prefect и т.д.) вы должны добавить шаг, который выполняет команду `dbt source freshness`.

**Ключевой момент:** Команда `dbt source freshness` возвращает код выхода (exit code):

- **`0` (ноль):** Все источники свежие (или только предупреждения).
    
- **`>0` (больше нуля):** Обнаружены ошибки актуальности (т.е., превышен порог `error_after` хотя бы для одного источника).
    

Стандартные CI/CD системы по умолчанию останавливают выполнение пайплайна, если любая команда возвращает ненулевой код выхода.

**Пример (псевдокод для CI/CD):**

YAML

```
# Пример YAML для CI/CD пайплайна (например, GitLab CI/CD или GitHub Actions)

stages:
  - check_freshness
  - build_models

check_freshness_job:
  stage: check_freshness
  script:
    - echo "Checking dbt source freshness..."
    - dbt deps # Убедитесь, что все зависимости установлены
    - dbt source freshness --select source:raw_data.events # Можно проверить конкретный источник
    # Или просто:
    # - dbt source freshness
    - echo "Source freshness check completed."
  allow_failure: false # Это важно! Если dbt source freshness вернет ошибку, этот шаг провалится и остановит пайплайн

build_models_job:
  stage: build_models
  script:
    - echo "Building dbt models..."
    - dbt build # Этот шаг выполнится только если check_freshness_job был успешен
    - echo "dbt models built."
  needs: [check_freshness_job] # Убедитесь, что этот шаг зависит от успешного выполнения проверки актуальности
```

**Что здесь происходит:**

1. **`check_freshness_job`:** Этот шаг запускает `dbt source freshness`.
    
2. **`allow_failure: false` (или эквивалент):** В большинстве CI/CD систем это поведение по умолчанию, но важно убедиться, что шаг не настроен на "игнорирование ошибок". Если `dbt source freshness` обнаружит источник, который старше порога `error_after`, он завершится с ненулевым кодом выхода.
    
3. **Остановка пайплайна:** Когда шаг завершается с ненулевым кодом выхода, CI/CD система интерпретирует это как сбой и **останавливает весь пайплайн**. Последующие шаги (например, `build_models_job`) не будут выполнены.
    

### Дополнительные соображения:

- **Гранулярность:** Вы можете запускать `dbt source freshness` для всех источников или использовать флаг `--select` для проверки только определенных источников, которые критичны для текущего пайплайна.
    
- **Оповещения:** Настройте CI/CD систему так, чтобы она отправляла уведомления (Slack, email и т.д.) при сбое шага `check_freshness_job`.
    
- **Расписание:** Часто проверку актуальности источников запускают по расписанию, независимо от основного пайплайна сборки, чтобы получать оповещения о проблемах с источниками до того, как они повлияют на сборку. Однако, если цель — предотвратить сборку на устаревших данных, то включение этого шага непосредственно перед `dbt run` или `dbt build` является правильным подходом.
    

Таким образом, комбинация правильной настройки `error_after` в `schema.yml` и запуска `dbt source freshness` в вашем CI/CD пайплайне гарантирует, что сборка dbt не будет происходить на данных, которые не соответствуют вашим требованиям к актуальности.